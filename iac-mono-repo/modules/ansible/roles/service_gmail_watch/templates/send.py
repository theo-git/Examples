from __future__ import print_function
import googleapiclient.discovery
import oauth2client
from oauth2client import client, tools
from oauth2client.service_account import ServiceAccountCredentials
import httplib2
import base64
import mimetypes
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from apiclient import errors, discovery
import json
import subprocess
import GmailServiceObject
from GmailServiceObject import SOURCE_EMAIL_ADDRESS, DESTINATION_EMAIL_ADDRESS

NEW_MESSAGE_LABELS = ['UNREAD', 'CATEGORY_PERSONAL', 'INBOX']


def main():
    to = DESTINATION_EMAIL_ADDRESS
    sender = SOURCE_EMAIL_ADDRESS
    subject = "{{ gmail_watch_email_subject_line }}".format(
        SOURCE_EMAIL_ADDRESS)
    msgHtml = "{{ gmail_watch_email_htmlBody }}".format(
        SOURCE_EMAIL_ADDRESS)
    msgPlain = "{{ gmail_watch_email_plainTXTBody }}".format(
        SOURCE_EMAIL_ADDRESS)
    user_id = "me"

    # Read the historyID file and store the last historyID generated by watch.py as a variable
    historyIDfile = open("historyID", "r")
    start_history_id = historyIDfile.read()
    print("The last Gmail historyID was: {}".format(start_history_id))
    InboxHistory = json.dumps(ListHistory(user_id, start_history_id))
    # Check if new messages where added to the inbox:
    if "messagesAdded" not in InboxHistory:
        print("NOTE: We didn't find a new message in {} so we didn't send an email to {}. This is usually due to the Gmail watch noticing an inbox change that wasn't a new message, like someone who deleted or sent a message from the source inbox.  This is usually not something to worry about unless the last POST request was certainly for a new inbox message.".format(
            SOURCE_EMAIL_ADDRESS, DESTINATION_EMAIL_ADDRESS))
    else:
        # Send an alert message:
        SendMessage(sender, to, subject, msgHtml, msgPlain)
        # Re-run the watch script to update the historyID file after sending:
        subprocess.Popen(["/bin/bash", "watch_inbox_initiate.sh",
                          '/opt/gmail_inbox_watch_alert/infra.crit'])
        print("Message to {} sent successfully!".format(
            DESTINATION_EMAIL_ADDRESS))

    '''
    Send message with attachment:
    SendMessage(sender, to, subject, msgHtml, msgPlain, '/path/to/file')
    '''
    '''Test message
    subject = "Test message, please disregard!"
    msgHtml = "This confirms that the {} inbox montoring and alerting scripts that we setup are working!<br/>".format(SOURCE_EMAIL_ADDRESS)
    msgPlain = "This confirms that the {} inbox montoring and alerting scripts that we setup are working!\n".format(SOURCE_EMAIL_ADDRESS)
    '''


def ListHistory(user_id, start_history_id):
    service = GmailServiceObject.AuthorizeService()
    try:
        history = (service.users().history().list(userId=user_id,
                                                  startHistoryId=start_history_id)
                   .execute())
        print("Here is the INBOX HISTORY since the last Gmail historyID update: {}".format(json.dumps(history)))
        return history
    except errors.HttpError, error:
        print('An error occurred: %s' % error)


def SendMessage(sender, to, subject, msgHtml, msgPlain, attachmentFile=None):
    service = GmailServiceObject.AuthorizeService()
    if attachmentFile:
        message1 = createMessageWithAttachment(
            sender, to, subject, msgHtml, msgPlain, attachmentFile)
    else:
        message1 = CreateMessageHtml(sender, to, subject, msgHtml, msgPlain)
    result = SendMessageInternal(service, "me", message1)
    return result


def SendMessageInternal(service, user_id, message):
    try:
        message = (service.users().messages().send(
            userId=user_id, body=message).execute())
        print('Message Id: %s' % message['id'])
        return message
    except errors.HttpError as error:
        print('An error occurred: %s' % error)
        return "Error"
    return "OK"


def CreateMessageHtml(sender, to, subject, msgHtml, msgPlain):
    msg = MIMEMultipart('alternative')
    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = to
    msg.attach(MIMEText(msgPlain, 'plain'))
    msg.attach(MIMEText(msgHtml, 'html'))
    return {'raw': base64.urlsafe_b64encode(msg.as_string())}


def createMessageWithAttachment(
        sender, to, subject, msgHtml, msgPlain, attachmentFile):
    """Create a message for an email.

    Args:
      sender: Email address of the sender.
      to: Email address of the receiver.
      subject: The subject of the email message.
      msgHtml: Html message to be sent
      msgPlain: Alternative plain text message for older email clients
      attachmentFile: The path to the file to be attached.

    Returns:
      An object containing a base64url encoded email object.
    """
    message = MIMEMultipart('mixed')
    message['to'] = to
    message['from'] = sender
    message['subject'] = subject

    messageA = MIMEMultipart('alternative')
    messageR = MIMEMultipart('related')

    messageR.attach(MIMEText(msgHtml, 'html'))
    messageA.attach(MIMEText(msgPlain, 'plain'))
    messageA.attach(messageR)

    message.attach(messageA)

    print("create_message_with_attachment: file: %s" % attachmentFile)
    content_type, encoding = mimetypes.guess_type(attachmentFile)

    if content_type is None or encoding is not None:
        content_type = 'application/octet-stream'
    main_type, sub_type = content_type.split('/', 1)
    if main_type == 'text':
        fp = open(attachmentFile, 'rb')
        msg = MIMEText(fp.read(), _subtype=sub_type)
        fp.close()
    elif main_type == 'image':
        fp = open(attachmentFile, 'rb')
        msg = MIMEImage(fp.read(), _subtype=sub_type)
        fp.close()
    elif main_type == 'audio':
        fp = open(attachmentFile, 'rb')
        msg = MIMEAudio(fp.read(), _subtype=sub_type)
        fp.close()
    else:
        fp = open(attachmentFile, 'rb')
        msg = MIMEBase(main_type, sub_type)
        msg.set_payload(fp.read())
        fp.close()
    filename = os.path.basename(attachmentFile)
    msg.add_header('Content-Disposition', 'attachment', filename=filename)
    message.attach(msg)

    return {'raw': base64.urlsafe_b64encode(message.as_string())}


if __name__ == '__main__':
    main()
